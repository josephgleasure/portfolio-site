<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Snowy Field Scene - Animated</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body, html {
      width: 100%;
      height: 100%;
      overflow: hidden;
    }
    
    #root {
      width: 100%;
      height: 100%;
      position: relative;
    }
    
    .background-image {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      z-index: 1;
    }
    
    #snow-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 2;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <div id="root">
    <!-- Background Image - loads from same folder -->
    <img 
      src="./snowy-field-background.jpg" 
      alt="Snowy Field Background" 
      class="background-image"
    >
    
    <!-- Snow Overlay Canvas -->
    <canvas id="snow-overlay"></canvas>
  </div>

  <script>
    // Snow overlay animation - matching the actual image density
    const canvas = document.getElementById('snow-overlay');
    const ctx = canvas.getContext('2d');
    let animationId;
    
    // Function to resize canvas
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      return { width: canvas.width, height: canvas.height };
    }
    
    let { width, height } = resizeCanvas();
    
    // Horizon line (where sky meets ground) - 55% down the screen
    const getHorizonY = () => height * 0.55;
    let horizonY = getHorizonY();
    
    // Depth layers configuration - REVERSED for realism
    // Layer 1: Far away (background) - VERY DENSE, tiny, slow (like your image!)
    // Layer 2: Middle distance - moderate density
    // Layer 3: Close (foreground) - SPARSE, large, fast
    const layers = [
      {
        snowflakes: [],
        maxCount: 10000,  // VERY DENSE background like your image
        initialCount: 5000,
        depth: 0.3, // Far away
        radiusMin: 0.3,
        radiusMax: 0.8,
        speedMin: 0.15,
        speedMax: 0.3,
        driftMin: -0.18,
        driftMax: 0.08,
        opacityMin: 0.6,
        opacityMax: 0.9
      },
      {
        snowflakes: [],
        maxCount: 5000,  // Medium density
        initialCount: 1300,
        depth: 0.6, // Middle distance
        radiusMin: 1.0,
        radiusMax: 1.8,
        speedMin: 0.4,
        speedMax: 0.6,
        driftMin: -0.15,
        driftMax: 0.15,
        opacityMin: 0.5,
        opacityMax: 0.7
      },
      {
        snowflakes: [],
        maxCount: 400,   // SPARSE foreground
        initialCount: 70,
        depth: 1.0, // Close/foreground
        radiusMin: 2.2,
        radiusMax: 4.0,
        speedMin: 0.8,
        speedMax: 1.4,
        driftMin: -0.35,
        driftMax: 0.35,
        opacityMin: 0.7,
        opacityMax: 0.95
      }
    ];
    
    // Animation timing
    const startTime = Date.now();
    const cycleDuration = 30000; // 30 seconds
    
    // Create initial snowflakes for each layer
    layers.forEach(layer => {
      for (let i = 0; i < layer.initialCount; i++) {
        layer.snowflakes.push({
          x: Math.random() * width,
          y: Math.random() * horizonY,
          radius: Math.random() * (layer.radiusMax - layer.radiusMin) + layer.radiusMin,
          speed: Math.random() * (layer.speedMax - layer.speedMin) + layer.speedMin,
          drift: Math.random() * (layer.driftMax - layer.driftMin) + layer.driftMin,
          opacity: Math.random() * (layer.opacityMax - layer.opacityMin) + layer.opacityMin,
          active: true
        });
      }
    });
    
    // Gradually increase snow density over 30 seconds for all layers
    function updateSnowflakeDensity() {
      const elapsed = Date.now() - startTime;
      const progress = (elapsed % cycleDuration) / cycleDuration;
      
      layers.forEach(layer => {
        const targetCount = Math.floor(layer.initialCount + (layer.maxCount - layer.initialCount) * progress);
        
        while (layer.snowflakes.length < targetCount) {
          layer.snowflakes.push({
            x: Math.random() * width,
            y: Math.random() * horizonY * 0.3,
            radius: Math.random() * (layer.radiusMax - layer.radiusMin) + layer.radiusMin,
            speed: Math.random() * (layer.speedMax - layer.speedMin) + layer.speedMin,
            drift: Math.random() * (layer.driftMax - layer.driftMin) + layer.driftMin,
            opacity: Math.random() * (layer.opacityMax - layer.opacityMin) + layer.opacityMin,
            active: true
          });
        }
      });
    }
    
    function drawSnowflakes() {
      // Draw layers from back to front (far to near)
      layers.forEach(layer => {
        layer.snowflakes.forEach(flake => {
          if (flake.active && flake.y < horizonY) {
            ctx.beginPath();
            ctx.arc(flake.x, flake.y, flake.radius, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(255, 255, 255, ${flake.opacity})`;
            ctx.fill();
            ctx.closePath();
          }
        });
      });
    }
    
    function updateSnowflakes() {
      layers.forEach(layer => {
        layer.snowflakes.forEach(flake => {
          if (!flake.active) return;
          
          flake.y += flake.speed;
          flake.x += flake.drift;
          
          // Reset when reaching horizon
          if (flake.y >= horizonY) {
            flake.y = -10;
            flake.x = Math.random() * width;
          }
          
          // Keep within horizontal bounds
          if (flake.x > width) {
            flake.x = 0;
          } else if (flake.x < 0) {
            flake.x = width;
          }
        });
      });
    }
    
    function animate() {
      ctx.clearRect(0, 0, width, height);
      updateSnowflakeDensity();
      drawSnowflakes();
      updateSnowflakes();
      animationId = requestAnimationFrame(animate);
    }
    
    // Handle window resize
    window.addEventListener('resize', () => {
      const newSize = resizeCanvas();
      width = newSize.width;
      height = newSize.height;
      horizonY = getHorizonY();
      
      // Adjust snowflakes for new dimensions in all layers
      layers.forEach(layer => {
        layer.snowflakes.forEach(flake => {
          if (flake.x > width) flake.x = Math.random() * width;
          if (flake.y > horizonY) flake.y = Math.random() * horizonY;
        });
      });
    });
    
    // Start animation
    animate();
  </script>
</body>
</html>
